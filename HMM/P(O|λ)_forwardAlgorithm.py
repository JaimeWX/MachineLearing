'''
算法说明
    λ,O 对应 P200 eg10.2 (α从1开始）
对算法的修改
    原算法只能解决len(Q) = 4 情况，修改后可以解决给定任意状态数的情况
'''
import numpy as np
### 前向算法计算条件概率
def prob_calc(O,A,B,pi):
    '''
    输入：
    O：观测序列, λ = (A,B,π)
    输出：
    alpha.sum()：条件概率
    '''
    # 初值
    alpha = pi * B[:, O[0]]   # α1(1) = π1 * b1(o1) α1(2) = π2 * b2(o1) α1(3) = π3 * b3(o1)
    # 递推
    for o in O[1:]:
        alpha_next = np.empty(len(alpha))
        for j in range(len(alpha)):   # 用len(alpha)来表示状态集合的个数
            # 双重for循环举例说明
            #   α2(1) = α1(1)*a11*b1(o2) + α1(2)*a21*b1(o2) + α1(3)*a31*b1(o2)
            #   α2(1)的解释说明
            #       首先解释α1(1)*a11*b1(o2): α1(1)表示第一次从第一个盒子中取得红球的概率为0.1
            #                                a11表示在第一次从第一个盒子中取得红球的基础上再次取到第一个盒子的概率为0.5
            #                                b1(o2)表示从第一个盒子中取到白球的概率为0.5
            #   所以α2(1) = 盒1取红盒1取白 + 盒2取红盒1取白 + 盒3取红盒1取白
            # 当o=1,j=0时，alpha_next[0]即对应α2(1)
            #   此时 A[:,j]对应a11,a21,a31; alpha对应α1(1),α1(2),α1(3); B[j,o]对应b1(o2)
            alpha_next[j] = np.sum(A[:,j] * alpha * B[j,o])
        alpha = alpha_next
    # 举例说明
    #   最后所求即为 P(O|λ) = α3(1)+α3(2)+α3(3)
    return alpha.sum()

# 给定观测
O = [0,1,0]
# 初始状态概率分布
pi = np.array([0.2,0.4,0.4])
# 状态转移概率矩阵
A = np.array([
    [0.5,0.2,0.3],
    [0.3,0.5,0.2],
    [0.2,0.3,0.5]])
# 观测概率矩阵
B = np.array([
    [0.5, 0.5],
    [0.4, 0.6],
    [0.7, 0.3]])
print(prob_calc(O,A,B,pi))